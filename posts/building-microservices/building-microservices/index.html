<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>&lt;Building Microservices Design Fine-Grained Systems> 筆記 - Tachunn Publication</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Introduction 這篇是 的筆記。分成三個部分 Foundation, Implementation, People。是我認為的 Microservices 我看過寫過最好的書。
Foundation Microservices 和 SOA 的差異？ Microservices 本身是 SOA 的子集合，SOA 只說明了是由 Service 組成(也就是 OS 的 Process)，但 Microservices 卻包含更多自己的設計原則。
Microservices 主要觀念？
能夠獨立部署 圍繞在 Business Domain。像是傳統都是分成 3-Tier 但是 Microservice 一個團隊就是以商業邏輯為導向組織團隊。 自己管理 State，算是前面一點的技術實作概念(擁有自己的 Database) Size 能夠被放進自己的大腦裡面，意味著邏輯並不會過度抽象與複雜。 Microservices 導入的技術？
Log Aggregation & Distributed Tracing: 當服務拆分的時候必須要能夠在分散式的環境統一遙測 Container & k8s: 加速整體的生命週期和管理方面的問題 Streaming: 分散式的非同步溝通 Microservice 的 Boundary 要考慮什麼？
Information Hiding 獨立部署 服務模組本身可以單獨理解其邏輯 對內可以改變實作的方式 Coupling 的方式 Microservices 彼此如何 Coupling? (以下由鬆到緊)
Domain Coupling 需要看 Interact 來彼此溝通。比如說 Order Processor 需要告訴 Warehouse 保留庫存，告訴 Payment 收錢。這種不可避免的，不然就不叫 Microservice 了。 Pass-Through Coupling Microservice 需要其他微服務的資料，經由另一個服務 Pass-Through 資料。糟糕之處就在於當下游的服務需要更動 Interface，比如說今天 Shipping 要採用新的計算格式好了，Order 和 Warehouse 都要進行更動。解法有兩個，第一就是直接由 Order 直接溝通兩個下游服務，但是這樣的邏輯會變得非常複雜，要先保留商品，然後寄送，兩件事情成功之後還要去 Warehouse 扣除。 另一種解法就是，一樣是靠 Warehouse pass-through 但是以 blob 的方式傳送，完全不去更動內部的資料。 3."><meta property="og:image" content><meta property="og:title" content="<Building Microservices Design Fine-Grained Systems> 筆記"><meta property="og:description" content="Introduction 這篇是 的筆記。分成三個部分 Foundation, Implementation, People。是我認為的 Microservices 我看過寫過最好的書。
Foundation Microservices 和 SOA 的差異？ Microservices 本身是 SOA 的子集合，SOA 只說明了是由 Service 組成(也就是 OS 的 Process)，但 Microservices 卻包含更多自己的設計原則。
Microservices 主要觀念？
能夠獨立部署 圍繞在 Business Domain。像是傳統都是分成 3-Tier 但是 Microservice 一個團隊就是以商業邏輯為導向組織團隊。 自己管理 State，算是前面一點的技術實作概念(擁有自己的 Database) Size 能夠被放進自己的大腦裡面，意味著邏輯並不會過度抽象與複雜。 Microservices 導入的技術？
Log Aggregation & Distributed Tracing: 當服務拆分的時候必須要能夠在分散式的環境統一遙測 Container & k8s: 加速整體的生命週期和管理方面的問題 Streaming: 分散式的非同步溝通 Microservice 的 Boundary 要考慮什麼？
Information Hiding 獨立部署 服務模組本身可以單獨理解其邏輯 對內可以改變實作的方式 Coupling 的方式 Microservices 彼此如何 Coupling? (以下由鬆到緊)
Domain Coupling 需要看 Interact 來彼此溝通。比如說 Order Processor 需要告訴 Warehouse 保留庫存，告訴 Payment 收錢。這種不可避免的，不然就不叫 Microservice 了。 Pass-Through Coupling Microservice 需要其他微服務的資料，經由另一個服務 Pass-Through 資料。糟糕之處就在於當下游的服務需要更動 Interface，比如說今天 Shipping 要採用新的計算格式好了，Order 和 Warehouse 都要進行更動。解法有兩個，第一就是直接由 Order 直接溝通兩個下游服務，但是這樣的邏輯會變得非常複雜，要先保留商品，然後寄送，兩件事情成功之後還要去 Warehouse 扣除。 另一種解法就是，一樣是靠 Warehouse pass-through 但是以 blob 的方式傳送，完全不去更動內部的資料。 3."><meta property="og:type" content="article"><meta property="og:url" content="https://tachunwu.github.io/posts/building-microservices/building-microservices/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-11T15:56:19+08:00"><meta property="article:modified_time" content="2022-10-11T15:56:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="<Building Microservices Design Fine-Grained Systems> 筆記"><meta name=twitter:description content="Introduction 這篇是 的筆記。分成三個部分 Foundation, Implementation, People。是我認為的 Microservices 我看過寫過最好的書。
Foundation Microservices 和 SOA 的差異？ Microservices 本身是 SOA 的子集合，SOA 只說明了是由 Service 組成(也就是 OS 的 Process)，但 Microservices 卻包含更多自己的設計原則。
Microservices 主要觀念？
能夠獨立部署 圍繞在 Business Domain。像是傳統都是分成 3-Tier 但是 Microservice 一個團隊就是以商業邏輯為導向組織團隊。 自己管理 State，算是前面一點的技術實作概念(擁有自己的 Database) Size 能夠被放進自己的大腦裡面，意味著邏輯並不會過度抽象與複雜。 Microservices 導入的技術？
Log Aggregation & Distributed Tracing: 當服務拆分的時候必須要能夠在分散式的環境統一遙測 Container & k8s: 加速整體的生命週期和管理方面的問題 Streaming: 分散式的非同步溝通 Microservice 的 Boundary 要考慮什麼？
Information Hiding 獨立部署 服務模組本身可以單獨理解其邏輯 對內可以改變實作的方式 Coupling 的方式 Microservices 彼此如何 Coupling? (以下由鬆到緊)
Domain Coupling 需要看 Interact 來彼此溝通。比如說 Order Processor 需要告訴 Warehouse 保留庫存，告訴 Payment 收錢。這種不可避免的，不然就不叫 Microservice 了。 Pass-Through Coupling Microservice 需要其他微服務的資料，經由另一個服務 Pass-Through 資料。糟糕之處就在於當下游的服務需要更動 Interface，比如說今天 Shipping 要採用新的計算格式好了，Order 和 Warehouse 都要進行更動。解法有兩個，第一就是直接由 Order 直接溝通兩個下游服務，但是這樣的邏輯會變得非常複雜，要先保留商品，然後寄送，兩件事情成功之後還要去 Warehouse 扣除。 另一種解法就是，一樣是靠 Warehouse pass-through 但是以 blob 的方式傳送，完全不去更動內部的資料。 3."><script src=https://tachunwu.github.io/js/feather.min.js></script>
<link href=https://tachunwu.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://tachunwu.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><div class=main><a href=https://tachunwu.github.io/>Tachunn Publication</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>&lt;Building Microservices Design Fine-Grained Systems> 筆記</h1><div class=meta>Posted on Oct 11, 2022</div></div><section class=body><h1 id=introduction>Introduction</h1><p>這篇是 的筆記。分成三個部分 Foundation, Implementation, People。是我認為的 Microservices 我看過寫過最好的書。</p><h1 id=foundation>Foundation</h1><blockquote><p>Microservices 和 SOA 的差異？
Microservices 本身是 SOA 的子集合，SOA 只說明了是由 Service 組成(也就是 OS 的 Process)，但 Microservices 卻包含更多自己的設計原則。</p></blockquote><blockquote><p>Microservices 主要觀念？</p></blockquote><ul><li>能夠獨立部署</li><li>圍繞在 Business Domain。像是傳統都是分成 3-Tier 但是 Microservice 一個團隊就是以商業邏輯為導向組織團隊。</li><li>自己管理 State，算是前面一點的技術實作概念(擁有自己的 Database)</li><li>Size 能夠被放進自己的大腦裡面，意味著邏輯並不會過度抽象與複雜。</li></ul><blockquote><p>Microservices 導入的技術？</p></blockquote><ol><li>Log Aggregation & Distributed Tracing: 當服務拆分的時候必須要能夠在分散式的環境統一遙測</li><li>Container & k8s: 加速整體的生命週期和管理方面的問題</li><li>Streaming: 分散式的非同步溝通</li></ol><blockquote><p>Microservice 的 Boundary 要考慮什麼？</p></blockquote><ul><li>Information Hiding<ul><li>獨立部署</li><li>服務模組本身可以單獨理解其邏輯</li><li>對內可以改變實作的方式</li></ul></li><li>Coupling 的方式</li></ul><blockquote><p>Microservices 彼此如何 Coupling?
(以下由鬆到緊)</p></blockquote><ol><li>Domain Coupling
需要看 Interact 來彼此溝通。比如說 Order Processor 需要告訴 Warehouse 保留庫存，告訴 Payment 收錢。這種不可避免的，不然就不叫 Microservice 了。</li><li>Pass-Through Coupling
Microservice 需要其他微服務的資料，經由另一個服務 Pass-Through 資料。糟糕之處就在於當下游的服務需要更動 Interface，比如說今天 Shipping 要採用新的計算格式好了，Order 和 Warehouse 都要進行更動。解法有兩個，第一就是直接由 Order 直接溝通兩個下游服務，但是這樣的邏輯會變得非常複雜，要先保留商品，然後寄送，兩件事情成功之後還要去 Warehouse 扣除。</li></ol><p>另一種解法就是，一樣是靠 Warehouse pass-through 但是以 blob 的方式傳送，完全不去更動內部的資料。
3. Common Coupling
這個情況發生在兩個服務需要用到相同的資料，比如說像 Order 和 Warehouse 都需要對訂單的狀態進行修改。最經典的解法就是引入 FSM 把不合法的狀態拒絕，但是這種狀態代表 code 的 cohesion 不夠，所以要進行重新設計。</p><ol start=4><li>Content Coupling
請直接避免這種問題！服務繞過商業邏輯，直接修改內部狀態，基本上會造成系統嚴重內部錯誤。</li></ol><blockquote><p>如何跨服務 Reference?</p></blockquote><blockquote><p>Microservice 溝通模式？</p></blockquote><ul><li>Synchronous blocking
定義：
優點：
缺點：
使用情境：</li><li>Asynchronous nonblocking
定義：
優點：
缺點：
使用情境：</li><li>Request-response
定義：
優點：
缺點：
使用情境：</li><li>Event-driven
定義：
優點：
缺點：
使用情境：</li><li>Common data
定義：
優點：
缺點：
使用情境：</li></ul><h1 id=implementation>Implementation</h1></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/coding>coding</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/tachunwu title=GitHub><i data-feather=github></i></a>
<a class=border></a></div><div class=footer-info>2022 💠 © Tachunn | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>