<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>&lt;Netflix 的軟體設計哲學：Hexagonal Archtecture> - Tachunn Publication</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Index 導言 前言 Chapter 1：高度的整合 Chapter 2：Monolith to Microservices Chapter 3：Hexagonal Architecture Core concepts Data Sources Transport Layer The dependency graph Chapter 4：Swapping data sources！ Production 實際情況 隱藏 data source 的細節 Chapter 5：Testing strategy Interactors test Data sources test E2E test 心得與總結 導言 這篇是整理翻譯 <Ready for changes with Hexagonal Architecture>，其中 Netflix 工程師把它們從 Monolith 轉換到 Microservices 然後介紹 Hexagonal Architecture 種種細節。
建議各位讀者把這篇當成故事，更能了解 Microservices 和 Hexagonal Architecture 誕生的因果。
前言 隨著每年的 Netflix 成長，我們實作 Application 的時候必須維持很高的效率。我們的 Engineering 組織從編劇、播放、排程、供應商管理、獲取劇本內容&mldr;etc，管理超多的 Applications 。"><meta property="og:image" content><meta property="og:title" content="<Netflix 的軟體設計哲學：Hexagonal Archtecture>"><meta property="og:description" content="Index 導言 前言 Chapter 1：高度的整合 Chapter 2：Monolith to Microservices Chapter 3：Hexagonal Architecture Core concepts Data Sources Transport Layer The dependency graph Chapter 4：Swapping data sources！ Production 實際情況 隱藏 data source 的細節 Chapter 5：Testing strategy Interactors test Data sources test E2E test 心得與總結 導言 這篇是整理翻譯 <Ready for changes with Hexagonal Architecture>，其中 Netflix 工程師把它們從 Monolith 轉換到 Microservices 然後介紹 Hexagonal Architecture 種種細節。
建議各位讀者把這篇當成故事，更能了解 Microservices 和 Hexagonal Architecture 誕生的因果。
前言 隨著每年的 Netflix 成長，我們實作 Application 的時候必須維持很高的效率。我們的 Engineering 組織從編劇、播放、排程、供應商管理、獲取劇本內容&mldr;etc，管理超多的 Applications 。"><meta property="og:type" content="article"><meta property="og:url" content="https://tachunwu.github.io/posts/hexagonal/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-23T16:47:26+08:00"><meta property="article:modified_time" content="2023-02-23T16:47:26+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="<Netflix 的軟體設計哲學：Hexagonal Archtecture>"><meta name=twitter:description content="Index 導言 前言 Chapter 1：高度的整合 Chapter 2：Monolith to Microservices Chapter 3：Hexagonal Architecture Core concepts Data Sources Transport Layer The dependency graph Chapter 4：Swapping data sources！ Production 實際情況 隱藏 data source 的細節 Chapter 5：Testing strategy Interactors test Data sources test E2E test 心得與總結 導言 這篇是整理翻譯 <Ready for changes with Hexagonal Architecture>，其中 Netflix 工程師把它們從 Monolith 轉換到 Microservices 然後介紹 Hexagonal Architecture 種種細節。
建議各位讀者把這篇當成故事，更能了解 Microservices 和 Hexagonal Architecture 誕生的因果。
前言 隨著每年的 Netflix 成長，我們實作 Application 的時候必須維持很高的效率。我們的 Engineering 組織從編劇、播放、排程、供應商管理、獲取劇本內容&mldr;etc，管理超多的 Applications 。"><script src=https://tachunwu.github.io/js/feather.min.js></script>
<link href=https://tachunwu.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://tachunwu.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><script async src="https://www.googletagmanager.com/gtag/js?id=G-2LYZQ778V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2LYZQ778V0")</script><div class=main><a href=https://tachunwu.github.io/>Tachunn Publication</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>&lt;Netflix 的軟體設計哲學：Hexagonal Archtecture></h1><div class=meta>Posted on Feb 23, 2023</div></div><section class=body><p><img src=/images/hexagonal_head.png alt><div><h2>Index</h2><nav id=TableOfContents><ol><li><a href=#導言><a href>導言</a></a></li><li><a href=#前言><a href>前言</a></a></li><li><a href=#chapter-1高度的整合><a href>Chapter 1：高度的整合</a></a></li><li><a href=#chapter-2monolith-to-microservices><a href>Chapter 2：Monolith to Microservices</a></a></li><li><a href=#chapter-3hexagonal-architecture><a href>Chapter 3：<strong><strong>Hexagonal Architecture</strong></strong></a></a><ol><li><a href=#core-concepts><a href>Core <strong><strong>concepts</strong></strong></a></a></li><li><a href=#data-sources><a href><strong>Data Sources</strong></a></a></li><li><a href=#transport-layer><a href><strong>Transport Layer</strong></a></a></li><li><a href=#the-dependency-graph><a href>The dependency graph</a></a></li></ol></li><li><a href=#chapter-4swapping-data-sources><a href>Chapter 4：<strong><strong>Swapping data sources！</strong></strong></a></a><ol><li><a href=#production-實際情況><a href>Production 實際情況</a></a></li><li><a href=#隱藏-data-source-的細節><a href>隱藏 data source 的細節</a></a></li></ol></li><li><a href=#chapter-5testing-strategy><a href>Chapter 5：<strong><strong>Testing strategy</strong></strong></a></a><ol><li><a href=#interactors-test><a href>Interactors test</a></a></li><li><a href=#data-sources-test><a href><strong>Data sources test</strong></a></a></li><li><a href=#e2e-test><a href>E2E <strong>test</strong></a></a></li></ol></li><li><a href=#心得與總結><a href>心得與總結</a></a></li></ol></nav></div></p><h1 id=導言><a href>導言</a></h1><p>這篇是整理翻譯 &lt;<strong><strong><a href=https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749>Ready for changes with Hexagonal Architecture</a></strong></strong>>，其中 Netflix 工程師把它們從 Monolith 轉換到 Microservices 然後介紹 Hexagonal Architecture 種種細節。</p><p><strong>建議各位讀者把這篇當成故事，更能了解 Microservices 和 Hexagonal Architecture 誕生的因果。</strong></p><h1 id=前言><a href>前言</a></h1><p>隨著每年的 Netflix 成長，我們實作 Application 的時候必須維持很高的效率。我們的 Engineering 組織從編劇、播放、排程、供應商管理、獲取劇本內容&mldr;etc，管理超多的 Applications 。</p><h1 id=chapter-1高度的整合><a href>Chapter 1：高度的整合</a></h1><p>大約一年前吧 (這裡指的是 2019年)，<strong>我們要開發一個超大型的專案，需要整合多個 Domain，而且還要管理超多的不同系統的 Database。</strong></p><p>具個例子來說好了，像是：</p><ul><li><strong>movies</strong></li><li><strong>production dates</strong></li><li><strong>employees</strong></li><li><strong>shooting locations</strong></li><li><strong>etc…</strong></li></ul><p>全部分散在不同的 services，protocols 也很多種，例如：</p><ul><li><strong>gRPC</strong></li><li><strong>JSON API</strong></li><li><strong>GraphQL</strong></li><li><strong>etc…</strong></li></ul><h1 id=chapter-2monolith-to-microservices><a href>Chapter 2：Monolith to Microservices</a></h1><p>當 Netflix 還是小公司的時候，我們為了 Application 的能見度，我們選擇 Monolith 架構。<strong>Monolith 可以超級快速的開發新功能。在某個時間點過後，我們有超過 30 個員工管理超過 300 個 database table！</strong></p><p>隨著時間的推移，Application 開始慢慢變得高度專業化。<strong>我們決定開始開始拆解 Monolith，這個決定不是因為性能問題，而是有些 Domain 太專業又複雜了，不得已分離出來獨自有自己的開發流程。</strong></p><p>隨著開始打造新的 Application，我們需要用到許多舊系統的資料，而麻煩的點在於這些資料分散在不同的 database 上。我們開始意識到把 monolith 拆分已經不可避免的會發生了，所以我們開始逐漸的從 Monolith 讀取出來放到新的 database，一旦 microservices 上線，我們就會切換到這些 data sources。</p><h1 id=chapter-3hexagonal-architecture><a href>Chapter 3：<strong><strong>Hexagonal Architecture</strong></strong></a></h1><p>我們決定用 Hexagonal Architecture 來解決上面的難題。</p><p><strong>Hexagonal Architecture 的想法是將 input 和 output 放在設計的邊緣，可以不影響商業邏輯的情況下更換 data sources。</strong></p><blockquote><p><strong>Hexagonal Architecture 的哲學是商業邏輯不應該依賴於任何 REST、GraphQL API，還有也不能依賴於 data 從哪裡來，甚至是從一個 CSV 檔讀取，都不能影響到商業邏輯。</strong></p></blockquote><p>其中一個最大的好處就是<strong>我們能夠獨立測試我們自己的商業邏輯有沒有問題。</strong></p><p><a href><em>註記</em></a>：<em>以下我會用我的理解寫一些 Go code，而這些並不是原始文章的內容，請讀者注意！</em></p><h2 id=core-concepts><a href>Core <strong><strong>concepts</strong></strong></a></h2><p>為了清楚的介紹 Hexagonal Architecture，我們要定義一下商業邏輯的三個名詞，分別是 <a href><strong>Entities, Repositories, Interactors</strong></a>。</p><h3 id=entities><strong>Entities</strong></h3><p><strong>Entities 代表 domain objects</strong>，例如：Movie、Shooting Location，<strong>它們自己完全不知道自己會被儲存在哪裡。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Movie</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>           <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 電影 ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Title</span>        <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 電影名稱
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ReleaseYear</span>  <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 上映年份
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Description</span>  <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 電影簡介
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ShootingLocation</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>        <span style=color:#66d9ef>int</span>    <span style=color:#75715e>// 拍攝地點 ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Name</span>      <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 拍攝地點名稱
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Address</span>   <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 拍攝地點地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>City</span>      <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 拍攝地點所在城市
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>State</span>     <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 拍攝地點所在州/省
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Country</span>   <span style=color:#66d9ef>string</span> <span style=color:#75715e>// 拍攝地點所在國家
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=repositories><strong>Repositories</strong></h3><p><strong>Repositories 是一種 Interface，確保 Entities 的建立和改變。Repositories 會提供一堆 methods 可以跟 data sources 溝通，比如說：回傳一個 User 或是一堆 Users。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>        <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Name</span>      <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Email</span>     <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CreatedAt</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>UpdatedAt</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserRepository</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 取得使用者 by ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>GetUserByID</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 取得所有使用者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>GetAllUsers</span>() ([]<span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 新增使用者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>CreateUser</span>(<span style=color:#a6e22e>user</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 更新使用者
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>UpdateUser</span>(<span style=color:#a6e22e>user</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 刪除使用者 by ID
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>DeleteUserByID</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=interactors><strong>Interactors</strong></h3><p><strong>Interactors 是用來實作與執行特定領域的動作或業務邏輯。這些類別通常被稱為 Service Objects 或 Use Case Objects，它們可以與 Repositories 和 Entities 一起使用</strong>，用於解決特定的問題或執行某些任務。</p><p><strong>Interactors 的主要職責是協調和執行領域相關的任務</strong>，例如：在電影製作上建立新的項目，管理項目內的資料，並檢查並驗證項目中的資料，它們也可以實現複雜的業務邏輯。</p><p>更細節來說像是在建立新的項目時，檢查一個項目是否符合特定的要求，並確保其遵循一些標準。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Production</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>             <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Title</span>          <span style=color:#66d9ef>string</span>       <span style=color:#75715e>// 片名
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ReleaseYear</span>    <span style=color:#66d9ef>int</span>          <span style=color:#75715e>// 發行年份
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Description</span>    <span style=color:#66d9ef>string</span>       <span style=color:#75715e>// 簡介
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ProductionDate</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>    <span style=color:#75715e>// 拍攝日期
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>ShootingLocation</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ShootingLocation</span>  <span style=color:#75715e>// 拍攝地點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Employees</span>      []<span style=color:#a6e22e>Employee</span>   <span style=color:#75715e>// 參與人員
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Employee</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>        <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>FirstName</span> <span style=color:#66d9ef>string</span>          <span style=color:#75715e>// 名字
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>LastName</span>  <span style=color:#66d9ef>string</span>          <span style=color:#75715e>// 姓氏
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ShootingLocation</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span>      <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Name</span>    <span style=color:#66d9ef>string</span>           <span style=color:#75715e>// 名稱
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Address</span> <span style=color:#66d9ef>string</span>           <span style=color:#75715e>// 地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProductionRepository</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Save</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>Production</span>) <span style=color:#66d9ef>error</span>   <span style=color:#75715e>// 儲存一部電影
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ShootingLocationRepository</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>FindByID</span>(<span style=color:#66d9ef>int</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>ShootingLocation</span>, <span style=color:#66d9ef>error</span>)   <span style=color:#75715e>// 依據 ID 取得拍攝地點
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProductionOnboardingInteractor</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>productionRepository</span>      <span style=color:#a6e22e>ProductionRepository</span>           <span style=color:#75715e>// 電影 Repository
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>shootingLocationRepository</span> <span style=color:#a6e22e>ShootingLocationRepository</span>     <span style=color:#75715e>// 拍攝地點 Repository
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewProductionOnboardingInteractor</span>(<span style=color:#a6e22e>pr</span> <span style=color:#a6e22e>ProductionRepository</span>, <span style=color:#a6e22e>slr</span> <span style=color:#a6e22e>ShootingLocationRepository</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>ProductionOnboardingInteractor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ProductionOnboardingInteractor</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>productionRepository</span>: <span style=color:#a6e22e>pr</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>shootingLocationRepository</span>: <span style=color:#a6e22e>slr</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>i</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ProductionOnboardingInteractor</span>) <span style=color:#a6e22e>OnboardProduction</span>(<span style=color:#a6e22e>title</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>releaseYear</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>description</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>productionDate</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Time</span>, <span style=color:#a6e22e>shootingLocationID</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>employees</span> []<span style=color:#a6e22e>Employee</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Production</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>shootingLocation</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>shootingLocationRepository</span>.<span style=color:#a6e22e>FindByID</span>(<span style=color:#a6e22e>shootingLocationID</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>empIDs</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>int</span>, len(<span style=color:#a6e22e>employees</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>e</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>employees</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>empIDs</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>ID</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>production</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Production</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Title</span>: <span style=color:#a6e22e>title</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ReleaseYear</span>: <span style=color:#a6e22e>releaseYear</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Description</span>: <span style=color:#a6e22e>description</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ProductionDate</span>: <span style=color:#a6e22e>productionDate</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ShootingLocation</span>: <span style=color:#a6e22e>shootingLocation</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Employees</span>: <span style=color:#a6e22e>employees</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>i</span>.<span style=color:#a6e22e>productionRepository</span>.<span style=color:#a6e22e>Save</span>(<span style=color:#a6e22e>production</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>production</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>有了前三個主要觀念，我們可以不用理會 Data Sources 和 Transport Layer 等細節，就可以驗證商業邏輯的正確性。</strong></p><h2 id=data-sources><a href><strong>Data Sources</strong></a></h2><p><strong>Data Source 實作了存取 Repository 所定義的方法，並且存儲和傳遞資料的實現方式。</strong></p><p>在 Hexagonal Architecture 中，<strong>Data Sources 位於應用程式核心邊緣，是與外部系統交互的接口。使用 Data Sources 的好處是，當需要更改儲存實作時，核心業務邏輯不會受到影響。</strong></p><p>Data Sources 可以是以下例子：</p><ul><li><strong>SQL database adapter</strong></li><li><strong>elastic search adapter</strong></li><li><strong>REST API</strong></li><li><strong>CSV file</strong></li></ul><h2 id=transport-layer><a href><strong>Transport Layer</strong></a></h2><p><strong>Transport Layer 是用來觸發 Interactors 進行業務邏輯處理的輸入介面。最常見 microservices 的 Transport Layer 是HTTP API Layer 和處理請求的 controller</strong>。通過將業務邏輯抽象到 Interactor 中。</p><p><strong>我們不會被限定於特定的 Transport Layer 或 controller。Interactor可以被各種方式觸發，不僅可以由 controller 觸發，還可以由 events、cron job、command line 觸發。</strong></p><h2 id=the-dependency-graph><a href>The dependency graph</a></h2><p>以下就是容易理解的 dependency graph。</p><p><img src=/images/hexagonal_0.png alt></p><p>傳統的架構都是一路向下依賴，例如：</p><ul><li><strong>Transport layer 依賴 Interactor Layer</strong></li><li><strong>Interactor Layer 依賴 Persistence layer</strong></li></ul><p>但在 Hexagonal Architecture，所有依賴都指向中心，分離了商業邏輯和外部的 Layer。但是我們還是保有以下優點，例如：</p><ul><li><strong>Transport layer 知道如何使用 interactors</strong></li><li><strong>Repository interface 也能使用 data sources</strong></li></ul><p>基於這些設計，轉換 data sources 就變成很容易的任務。</p><h1 id=chapter-4swapping-data-sources><a href>Chapter 4：<strong><strong>Swapping data sources！</strong></strong></a></h1><h2 id=production-實際情況><a href>Production 實際情況</a></h2><p>雖然說比預期的還要早切換 data sources，<strong>我們最終用上面的架構在 2小時內完成了從 JSON API 到 GraphQL，而且只修改了一行 code 就行！</strong></p><p>在過程中突然遇到讀取限制的問題，為了解決這個問題，需要將某個 Entity 的讀取轉換成一個新的微服務。<strong>這個微服務透過 GraphQL 聚合層提供服務。這個微服務與單體應用程式保持同步，並且擁有相同的數據，從其中一個服務讀取或從另一個服務讀取產生相同的結果。</strong></p><p><img src=/images/hexagonal_1.png alt></p><h2 id=隱藏-data-source-的細節><a href>隱藏 data source 的細節</a></h2><p>其中一個好處就是就是能夠封裝 data source 實作的細節。</p><p>我們有一個 case 是我們需要呼叫下游的 API，不過下游的團隊沒有實作 bulk fetch，只有 single fetch，明顯需要一些時間實作。</p><p>那怎麼麼辦呢？</p><p><strong>團隊溝通後決定用一個方法，我們在 repository 中加入一個 method，會 concurrent call 下游的 single fetch，然後加上 record id，雖然只是暫時的解決方案，但是我們只需要修改一點點的 code，就可以達到我們要的效果。</strong></p><p><img src=/images/hexagonal_2.png alt></p><p><strong>這個架構可以幫我們更快的交付產品，而且更容易地維護和擴展系統，同時降低了風險和成本。</strong></p><h1 id=chapter-5testing-strategy><a href>Chapter 5：<strong><strong>Testing strategy</strong></strong></a></h1><p>當然啦~選擇 Hexagonal Architecture 我們就想好了測試的策略，以下就介紹一下。</p><h2 id=interactors-test><a href>Interactors test</a></h2><p>Interactors test，測試最核心的功能，這裡是我們的商業邏輯，我們會搭配 mock type repository。<strong>由於是核心商業邏輯，我們會測到非常非常細節</strong>。</p><p><img src=/images/hexagonal_3.png alt></p><h2 id=data-sources-test><a href><strong>Data sources test</strong></a></h2><p><strong>接著就是測試 repository interface 有沒有接到 data sources，確保東西真的有寫進去。</strong></p><p><img src=/images/hexagonal_4.png alt></p><h2 id=e2e-test><a href>E2E <strong>test</strong></a></h2><p>最後就是全面的測試，在 Hexagonal Architecture 中，我們有一組集成測試 (Integration specs)。這些測試會從我們的 <strong>Transport / API layer 開始，通過 interactors、repositories、data sources，直到最後打到下游服務 (downstream services)</strong>。</p><p><strong>如果一個 data source 是外部的 API，我們會打這個 API 並且記錄下回傳的 response（並將它們儲存在 git 中）</strong>，這樣我們的測試套件在之後的每一次執行上都可以快速運作。對於這層，<strong>我們不會進行全面的測試涵蓋，通常每個 domain action 只有一個成功情境和一個失敗情境。</strong></p><p><img src=/images/hexagonal_5.png alt></p><h1 id=心得與總結><a href>心得與總結</a></h1><p>這篇文章應該算是 SaaS 和開發微服務的必讀文章，概念其實和 Clean Architecture 蠻像的，不過 Netflix 更鉅細靡遺告訴我們細節，算是作為 Back-end SWE 的入門磚吧，感謝作者的分享！</p></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/tachunwu rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a></div><div class=footer-info>2023 💠 © Tachunn | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-2LYZQ778V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2LYZQ778V0")</script><script>feather.replace()</script></div></body></html>