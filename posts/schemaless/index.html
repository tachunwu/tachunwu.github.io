<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>&lt;Uber Schema-less 的系統起源> - Tachunn Publication</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Index 前情提要 故事背景 先用老招 尋找新的 Infra，然後放棄 手動打造新的系統 Schema-less Overview 細節 Consistency and Atomicity Performance 感想 前情提要 這篇文章會被我研究到也是有些故事，由於蠻有趣的所以我就提一下，希望能夠勾起讀者的興趣！有天我在研究 Uber 的 Schemaless 系統時發現的一些趣事。
(以下是三篇文章的關鍵字，由於台灣的 Uber TW 網站掛掉了，我整理一下關鍵字，大家之後可以搜尋看看)
<Designing Schemaless, Uber Engineering&rsquo;s Scalable Datastore Using MySQL> <Using Triggers On Schemaless, Uber Engineering&rsquo;s Datastore Using MySQL> <The Architecture of Schemaless, Uber Engineering&rsquo;s Trip Datastore Using MySQL> 這幾篇文章都很有趣，但是我仔細檢查之下，發現他們在文中有引用到別人的想法，那我為甚麼不去研究原版呢？這樣不是概念更清楚嗎 XD？
我就找到這篇文章，也就是 <How FriendFeed uses MySQL to store schema-less data>。在我做了一些搜尋之後，發現這篇文章來頭可不小！
這篇文章是由 Bret Taylor 所寫的，他是 Google Maps 的共同創作者，也是 Facebook 一段時間的 CTO，目前是 Salesforce 的 CEO。而 FriendFeed 其實就是做和 facebook 差不多的事情，最後被 facebook 收購，可以發現 Logo 和 facebook 是如此相似！"><meta property="og:image" content><meta property="og:title" content="<Uber Schema-less 的系統起源>"><meta property="og:description" content="Index 前情提要 故事背景 先用老招 尋找新的 Infra，然後放棄 手動打造新的系統 Schema-less Overview 細節 Consistency and Atomicity Performance 感想 前情提要 這篇文章會被我研究到也是有些故事，由於蠻有趣的所以我就提一下，希望能夠勾起讀者的興趣！有天我在研究 Uber 的 Schemaless 系統時發現的一些趣事。
(以下是三篇文章的關鍵字，由於台灣的 Uber TW 網站掛掉了，我整理一下關鍵字，大家之後可以搜尋看看)
<Designing Schemaless, Uber Engineering&rsquo;s Scalable Datastore Using MySQL> <Using Triggers On Schemaless, Uber Engineering&rsquo;s Datastore Using MySQL> <The Architecture of Schemaless, Uber Engineering&rsquo;s Trip Datastore Using MySQL> 這幾篇文章都很有趣，但是我仔細檢查之下，發現他們在文中有引用到別人的想法，那我為甚麼不去研究原版呢？這樣不是概念更清楚嗎 XD？
我就找到這篇文章，也就是 <How FriendFeed uses MySQL to store schema-less data>。在我做了一些搜尋之後，發現這篇文章來頭可不小！
這篇文章是由 Bret Taylor 所寫的，他是 Google Maps 的共同創作者，也是 Facebook 一段時間的 CTO，目前是 Salesforce 的 CEO。而 FriendFeed 其實就是做和 facebook 差不多的事情，最後被 facebook 收購，可以發現 Logo 和 facebook 是如此相似！"><meta property="og:type" content="article"><meta property="og:url" content="https://tachunwu.github.io/posts/schemaless/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-05T22:08:57+08:00"><meta property="article:modified_time" content="2023-02-05T22:08:57+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="<Uber Schema-less 的系統起源>"><meta name=twitter:description content="Index 前情提要 故事背景 先用老招 尋找新的 Infra，然後放棄 手動打造新的系統 Schema-less Overview 細節 Consistency and Atomicity Performance 感想 前情提要 這篇文章會被我研究到也是有些故事，由於蠻有趣的所以我就提一下，希望能夠勾起讀者的興趣！有天我在研究 Uber 的 Schemaless 系統時發現的一些趣事。
(以下是三篇文章的關鍵字，由於台灣的 Uber TW 網站掛掉了，我整理一下關鍵字，大家之後可以搜尋看看)
<Designing Schemaless, Uber Engineering&rsquo;s Scalable Datastore Using MySQL> <Using Triggers On Schemaless, Uber Engineering&rsquo;s Datastore Using MySQL> <The Architecture of Schemaless, Uber Engineering&rsquo;s Trip Datastore Using MySQL> 這幾篇文章都很有趣，但是我仔細檢查之下，發現他們在文中有引用到別人的想法，那我為甚麼不去研究原版呢？這樣不是概念更清楚嗎 XD？
我就找到這篇文章，也就是 <How FriendFeed uses MySQL to store schema-less data>。在我做了一些搜尋之後，發現這篇文章來頭可不小！
這篇文章是由 Bret Taylor 所寫的，他是 Google Maps 的共同創作者，也是 Facebook 一段時間的 CTO，目前是 Salesforce 的 CEO。而 FriendFeed 其實就是做和 facebook 差不多的事情，最後被 facebook 收購，可以發現 Logo 和 facebook 是如此相似！"><script src=https://tachunwu.github.io/js/feather.min.js></script>
<link href=https://tachunwu.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://tachunwu.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><script async src="https://www.googletagmanager.com/gtag/js?id=G-2LYZQ778V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2LYZQ778V0")</script><div class=main><a href=https://tachunwu.github.io/>Tachunn Publication</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>&lt;Uber Schema-less 的系統起源></h1><div class=meta>Posted on Feb 5, 2023</div></div><section class=body><p><img src=/images/schemaless_head.png alt><div><h2>Index</h2><nav id=TableOfContents><ol><li><a href=#前情提要><strong>前情提要</strong></a></li><li><a href=#故事背景><strong>故事背景</strong></a></li><li><a href=#先用老招><strong>先用老招</strong></a></li><li><a href=#尋找新的-infra然後放棄><strong>尋找新的 Infra，然後放棄</strong></a></li><li><a href=#手動打造新的系統-schema-less><strong>手動打造新的系統 Schema-less</strong></a></li><li><a href=#overview><strong>Overview</strong></a><ol><li><a href=#細節><strong>細節</strong></a></li><li><a href=#consistency-and-atomicity><strong>Consistency and Atomicity</strong></a></li><li><a href=#performance><strong>Performance</strong></a></li></ol></li><li><a href=#感想><strong>感想</strong></a></li></ol></nav></div></p><h1 id=前情提要><strong>前情提要</strong></h1><p>這篇文章會被我研究到也是有些故事，由於蠻有趣的所以我就提一下，希望能夠勾起讀者的興趣！有天我在研究 Uber 的 Schemaless 系統時發現的一些趣事。</p><p>(以下是三篇文章的關鍵字，由於台灣的 Uber TW 網站掛掉了，我整理一下關鍵字，大家之後可以搜尋看看)</p><ul><li><a href><strong>&lt;Designing Schemaless, Uber Engineering&rsquo;s Scalable Datastore Using MySQL></strong></a></li><li><a href><strong>&lt;Using Triggers On Schemaless, Uber Engineering&rsquo;s Datastore Using MySQL></strong></a></li><li><a href><strong>&lt;The Architecture of Schemaless, Uber Engineering&rsquo;s Trip Datastore Using MySQL></strong></a></li></ul><p>這幾篇文章都很有趣，但是我仔細檢查之下，發現他們在文中<a href>有引用到別人的想法，那我為甚麼不去研究原版呢？這樣不是概念更清楚嗎 XD？</a></p><p>我就找到這篇文章，也就是 &lt;<a href=https://backchannel.org/blog/friendfeed-schemaless-mysql><strong>How FriendFeed uses MySQL to store schema-less data</strong></a>>。在我做了一些搜尋之後，發現這篇文章來頭可不小！</p><p><a href>這篇文章是由 <strong>Bret Taylor 所寫的，他是 Google Maps 的共同創作者，也是 Facebook 一段時間的 CTO，目前是 Salesforce 的 CEO</strong>。而 <strong>FriendFeed 其實就是做和 facebook 差不多的事情，最後被 facebook 收購，可以發現 Logo 和 facebook 是如此相似！</strong></a></p><p><img src=/images/schemaless_0.png alt></p><p>講完前導故事我們進入正文吧！</p><h1 id=故事背景><strong>故事背景</strong></h1><p>一開始我們使用 MySQL 儲存所有 FriendFeed 的資料，資料成長到一個很大量的程度，<a href><strong>我們現在儲存了 250 million 的資料，其中包含留言、好友名單、讚數之類的。</strong></a></p><h1 id=先用老招><strong>先用老招</strong></h1><p>當然，當資料庫擴張的時候，我們嘗試了許多方式來應急。例如：</p><ul><li><a href><strong>用 read slaves (現在應該要講 replica XD) + memcached 去增加 read throughput</strong></a></li><li><a href><strong>sharding 來增加 write throughput</strong></a></li></ul><p>隨著我們成長，這些流量讓我們很難開發新的功能，下面就是血淋淋的實例。</p><p><a href><strong>特別是當我們做 schema change 或是 add indexes 到 database 的時候，10~20 million 的 rows 會完完全全 lock 我們的 database 好幾個小時！如果移除沒有用到 indexes 也要花很多時間，但是不刪除它們會非常傷效能，因為當執行 INSERT 的時候會持續讀寫那些 block。</strong></a></p><p>作者有提到，他有想到一些 operational procedures 來解決問題，例如：開一個 index 在 slave，然後交換 master 和 slave 的角色，但是這些方法太容易出錯了，尤其當我們 sharding 了 database，JOIN 已經不管用了，我們勢必要尋找新的方法來根本性的解決這些問題。</p><h1 id=尋找新的-infra然後放棄><strong>尋找新的 Infra，然後放棄</strong></h1><p>在當時的時空背景，<strong>有很多 project 都試圖解決我們遇到的問題，像是有 flexible schemas 還有 indexes on-the-fly</strong>。<a href><strong>例如：CouchDB，但是他們都太理想化了，我根本沒有看到像我們一樣這麼大規模的 SaaS 有在用這些解決方案，實在沒有信心阿！</strong></a></p><h1 id=手動打造新的系統-schema-less><strong>手動打造新的系統 Schema-less</strong></h1><p>在我們內部開會之後，我們決定自己打造一個新的儲存系統叫做 <a href><strong>“Schema-less”</strong>，這是一種打造在 MySQL 之上的系統來滿足我們的需要</a>，我們會在後面的篇幅跟大家介紹我們怎麼設計的。</p><h1 id=overview><strong>Overview</strong></h1><p>我們的的系統儲存了一系列的資料結構，<a href>例如</a>：JSON、Python dictionaries。<strong>如果我們需要讀取它們我們只需要一個 id，也就是常見的 16-byte UUID</strong>，<strong>在 datastore 的層級這些東西都會變成 bytes 所以我們可以根據開發新的 feature 需要去動態修改</strong> (只要 Application Layer 知道怎麼轉回來就好)。</p><p>我們個<a href><strong>別將這些 entities 加上 index，然後分散在許多 MySQL 的 table 上。如果我們想要 index 三個 entity 的 properties，我們就會開三張 table，負責各自的 index。</strong></a></p><p><a href><strong>如果我們想要一個新的 index，就創一張新的 table，然後開一個 process asynchronous 的更新它，完全不會打亂我們線上的服務。</strong></a></p><p><a href><strong>從結論上來看，我們有了更多的 table，但是增加和刪除都變得超輕鬆！</strong> 我們自己有寫一個叫做 <strong>“The Cleaner” 的 process</strong> (當然有做大量優化)，讓我們<strong>可以在一天之內的時間搞定新的 index。</strong></a></p><h2 id=細節><strong>細節</strong></h2><p>接著我們進入細節，以下先解釋一下我們 entities table 的格式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> entities (
</span></span><span style=display:flex><span>    added_id INT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> AUTO_INCREMENT <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>    id BINARY(<span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    updated <span style=color:#66d9ef>TIMESTAMP</span> <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    body MEDIUMBLOB,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>UNIQUE</span> <span style=color:#66d9ef>KEY</span> (id),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>KEY</span> (updated)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB;
</span></span></code></pre></div><p>added_id 之所以會存在是因為 InnoDB 對 row 的物理儲存是依照 primary key order。<code>AUTO_INCREMENT</code> primary key 則是確保新的 entities 是序列化的寫入 Disk。</p><p>這對我們的服務來說是件好事，<a href><strong>因為 FriendFeed 是依照時間來排序的，新的東西讀取會遠比舊的多。欄位中 Entity bodies 用 zlib-compressed pickled 轉成 bytes，所以說底層不用知道欄位的內容實際上是什麼。</strong></a></p><p><a href><strong>而 indexes 則是存在分開的 table</strong></a>。舉例來說，我們創造一個新的 table 用來儲存 attributes。</p><p>舉例來說，一個 FriendFeed 的 entity 長的會像是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;id&#34;</span>: <span style=color:#e6db74>&#34;71f0c4d2291844cca2df6f486e96e37c&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;user_id&#34;</span>: <span style=color:#e6db74>&#34;f48b0440ca0c4f66991c4d5f6a078eaf&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;feed_id&#34;</span>: <span style=color:#e6db74>&#34;f48b0440ca0c4f66991c4d5f6a078eaf&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;title&#34;</span>: <span style=color:#e6db74>&#34;We just launched a new backend system for FriendFeed!&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;link&#34;</span>: <span style=color:#e6db74>&#34;http://friendfeed.com/e/71f0c4d2-2918-44cc-a2df-6f486e96e37c&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;published&#34;</span>: <span style=color:#ae81ff>1235697046</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;updated&#34;</span>: <span style=color:#ae81ff>1235697046</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果我們想要 index 上在 user_id 這個屬性， 這樣我們可以開發一個 feature 像是給定一個 user_id 列出她所有的貼文，已下會是 index table 的樣子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> index_user_id (
</span></span><span style=display:flex><span>    user_id BINARY(<span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    entity_id BINARY(<span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>UNIQUE</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (user_id, entity_id)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB;
</span></span></code></pre></div><p>我們的 datastore 會根據使用者的行為自動維護 index，下面是實際的例子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>user_id_index <span style=color:#f92672>=</span> friendfeed<span style=color:#f92672>.</span>datastore<span style=color:#f92672>.</span>Index(
</span></span><span style=display:flex><span>    table<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;index_user_id&#34;</span>, properties<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;user_id&#34;</span>], shard_on<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;user_id&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>datastore <span style=color:#f92672>=</span> friendfeed<span style=color:#f92672>.</span>datastore<span style=color:#f92672>.</span>DataStore(
</span></span><span style=display:flex><span>    mysql_shards<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;127.0.0.1:3306&#34;</span>, <span style=color:#e6db74>&#34;127.0.0.1:3307&#34;</span>],
</span></span><span style=display:flex><span>    indexes<span style=color:#f92672>=</span>[user_id_index])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>new_entity <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;id&#34;</span>: binascii<span style=color:#f92672>.</span>a2b_hex(<span style=color:#e6db74>&#34;71f0c4d2291844cca2df6f486e96e37c&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;user_id&#34;</span>: binascii<span style=color:#f92672>.</span>a2b_hex(<span style=color:#e6db74>&#34;f48b0440ca0c4f66991c4d5f6a078eaf&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;feed_id&#34;</span>: binascii<span style=color:#f92672>.</span>a2b_hex(<span style=color:#e6db74>&#34;f48b0440ca0c4f66991c4d5f6a078eaf&#34;</span>),
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;title&#34;</span>: <span style=color:#e6db74>u</span><span style=color:#e6db74>&#34;We just launched a new backend system for FriendFeed!&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;link&#34;</span>: <span style=color:#e6db74>u</span><span style=color:#e6db74>&#34;http://friendfeed.com/e/71f0c4d2-2918-44cc-a2df-6f486e96e37c&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;published&#34;</span>: <span style=color:#ae81ff>1235697046</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;updated&#34;</span>: <span style=color:#ae81ff>1235697046</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>datastore<span style=color:#f92672>.</span>put(new_entity)
</span></span><span style=display:flex><span>entity <span style=color:#f92672>=</span> datastore<span style=color:#f92672>.</span>get(binascii<span style=color:#f92672>.</span>a2b_hex(<span style=color:#e6db74>&#34;71f0c4d2291844cca2df6f486e96e37c&#34;</span>))
</span></span><span style=display:flex><span>entity <span style=color:#f92672>=</span> user_id_index<span style=color:#f92672>.</span>get_all(datastore, user_id<span style=color:#f92672>=</span>binascii<span style=color:#f92672>.</span>a2b_hex(<span style=color:#e6db74>&#34;f48b0440ca0c4f66991c4d5f6a078eaf&#34;</span>))
</span></span></code></pre></div><p>解釋一下上面這段 code，<a href><strong>Index Class 會尋找 user_id，然後自動維護 index_user_id table</strong></a>。由於我們把 database sharded 了，能透過簡單的計算找出要存在哪裡，<a href>例如</a>：<a href>entity[&ldquo;user_id&rdquo;] % num_shards。</a></p><p><strong>你也可以 query 一個 index，像是上面 <code>user_id_index.get_all</code> 這個實例</strong>。<a href><strong>datastore 可以在 Python 模擬 index_user_id table 和 entities table 的 JOIN 功能</strong></a>，<strong><a href>先對所有 shard 查詢 index_user_id table 會得到一個 list entity IDs，然後再去 entities table 抓資料。</a></strong></p><p>如果要增加一個 index 在 link 這個屬性上面，我們可以建造一個新的表格：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> index_link (
</span></span><span style=display:flex><span>    link VARCHAR(<span style=color:#ae81ff>735</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>    entity_id BINARY(<span style=color:#ae81ff>16</span>) <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>UNIQUE</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span> (link, entity_id)
</span></span><span style=display:flex><span>) ENGINE<span style=color:#f92672>=</span>InnoDB <span style=color:#66d9ef>DEFAULT</span> CHARSET<span style=color:#f92672>=</span>utf8;
</span></span></code></pre></div><p>修改一下 code 就可以把這個新的 index 包含進去：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>user_id_index <span style=color:#f92672>=</span> friendfeed<span style=color:#f92672>.</span>datastore<span style=color:#f92672>.</span>Index(
</span></span><span style=display:flex><span>    table<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;index_user_id&#34;</span>, properties<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;user_id&#34;</span>], shard_on<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;user_id&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>link_index <span style=color:#f92672>=</span> friendfeed<span style=color:#f92672>.</span>datastore<span style=color:#f92672>.</span>Index(
</span></span><span style=display:flex><span>    table<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;index_link&#34;</span>, properties<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;link&#34;</span>], shard_on<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;link&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>datastore <span style=color:#f92672>=</span> friendfeed<span style=color:#f92672>.</span>datastore<span style=color:#f92672>.</span>DataStore(
</span></span><span style=display:flex><span>    mysql_shards<span style=color:#f92672>=</span>[<span style=color:#e6db74>&#34;127.0.0.1:3306&#34;</span>, <span style=color:#e6db74>&#34;127.0.0.1:3307&#34;</span>],
</span></span><span style=display:flex><span>    indexes<span style=color:#f92672>=</span>[user_id_index, link_index])
</span></span></code></pre></div><p><a href><strong>甚至系統還在上線，我們也能夠執行一些腳本去 asynchronously 讀取 index。</strong></a></p><h2 id=consistency-and-atomicity><strong>Consistency and Atomicity</strong></h2><p>雖然上面提供了很美好的解法，<a href><strong>但是我們有個問題，由於東西全面分散了，我們要怎麼管理一致性？</strong></a> 舉例來說：如果我們寫完所有的 index 之前就 crash 了，這就是個大問題！</p><p>打造一個 transaction protocol 雖然很吸引人，<a href><strong>但是我們真的希望系統可以簡單就好</strong></a>，所以我們採取了以下的取捨。</p><ul><li><strong>property bag 和 entities table 是中心化的</strong></li><li><strong>Indexes 可能不會反映真實的 entity values</strong></li></ul><p>結論就是當寫入一個新的 entity，會依照下面的步驟：</p><ol><li><strong>要寫入 entity 時用 ACID 的標準寫入 entities table</strong></li><li><strong>把 index 寫入所有的 shard 上的 index tables</strong></li></ol><p>當我們從 index tables 讀取資料的時候，我們知道很可能東西是不正確的，舉例來說：還停留在上一個階段，因為上次寫到一半 Application Server 掛點了。為了正確性，我們採取以下步驟：</p><ol><li><strong>從 index tables 讀取 entity_id</strong></li><li><strong>從 entities table 讀取 entities 用上面的到的 IDs</strong></li><li><strong>在應用程式中 Filter 掉不正確的資料</strong></li></ol><p>最後，<a href><strong>為了確保 indexes 不會永遠的是錯誤的 value，上面提到的 “The Cleaner”，會像 daemon 一樣把 entities table 把錯誤的 index 修復完成。為了應用程式的特性，會根據最近的時間去修復，作者說實際上通常就算是錯誤，幾秒內就能修復完畢。</strong></a></p><h2 id=performance><strong>Performance</strong></h2><p>我們優化了 primary indexes，對於結果我們常滿意，view latency 有戲劇性的轉變。</p><p><img src=/images/schemaless_1.png alt></p><p>除此之外，穩定性也非常好，這是最近 24 小時的 peaks 變化圖：</p><p><img src=/images/schemaless_2.png alt></p><p>最後用一週的時間來分析結果</p><p><img src=/images/schemaless_3.png alt></p><h1 id=感想><strong>感想</strong></h1><p><strong>這篇文章是 2009 年寫的，當時可不像現在有那麼多的可靠又成熟資料庫可以選擇，甚至連 NoSQL 在大眾市場都不算成熟，但是該解決的問題還是要解決。</strong></p><p>我想<a href><strong>不論在什麼時代都一定會有一些很可靠的舊技術和很搶眼的新技術</strong></a>，對於維護真正的服務的人往往都要做出選擇，每讀一篇這種在當時第一線的人做的決定和思考，讓我學習到很多眉眉角角。說穿了這些東西我想講講大家都會，但是能夠構思的多全面，卻又是另一個哲學問題！感謝作者給我的感動。</p></section><div class=post-tags></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/tachunwu rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a></div><div class=footer-info>2023 💠 © Tachunn | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-2LYZQ778V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2LYZQ778V0")</script><script>feather.replace()</script></div></body></html>