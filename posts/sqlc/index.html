<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>&lt;How We Went All In on ：sqlc/pgx for Postgres + Go> - Tachunn Publication</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="註記：作者本人有攝影的興趣，我拿他的一張相片當封面 XD
Index 導言 前言 Tour database/sql lib/pq pgx go-pg gorm Research Queries as strings ORMs sqlc Codegen pgx support appears Caveats and workarounds Summary and future 導言 這篇文章是專為 Go 開發者寫的，主要翻譯 <How We Went All In on sqlc/pgx for Postgres + Go>，這篇文章的作者本身在 Heroku 工作過也在 stripe 工作過，同時也是提出 Idempotent Key API 的人。
現在他在 Crunchy Data 開發 platform API，對於 Postgres 和 Go 都算是非常有經驗的專家，這篇文章會分享一些他對當前生態環境 Go 如何操作 Postgres 的一些看法。
前言 幾個月的實驗和研究後，我們跑了一些 DB-dependent Go app，我們得到一個結論就是 sqlc 可以說是最好的拿來使用的 Postgres (可以能其他 databases 也是)。而且在 Go code 也很容易使用，以下就讓來介紹一下我們的研究吧！"><meta property="og:image" content><meta property="og:title" content="<How We Went All In on ：sqlc/pgx for Postgres + Go>"><meta property="og:description" content="註記：作者本人有攝影的興趣，我拿他的一張相片當封面 XD
Index 導言 前言 Tour database/sql lib/pq pgx go-pg gorm Research Queries as strings ORMs sqlc Codegen pgx support appears Caveats and workarounds Summary and future 導言 這篇文章是專為 Go 開發者寫的，主要翻譯 <How We Went All In on sqlc/pgx for Postgres + Go>，這篇文章的作者本身在 Heroku 工作過也在 stripe 工作過，同時也是提出 Idempotent Key API 的人。
現在他在 Crunchy Data 開發 platform API，對於 Postgres 和 Go 都算是非常有經驗的專家，這篇文章會分享一些他對當前生態環境 Go 如何操作 Postgres 的一些看法。
前言 幾個月的實驗和研究後，我們跑了一些 DB-dependent Go app，我們得到一個結論就是 sqlc 可以說是最好的拿來使用的 Postgres (可以能其他 databases 也是)。而且在 Go code 也很容易使用，以下就讓來介紹一下我們的研究吧！"><meta property="og:type" content="article"><meta property="og:url" content="https://tachunwu.github.io/posts/sqlc/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-19T16:58:55+08:00"><meta property="article:modified_time" content="2023-02-19T16:58:55+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="<How We Went All In on ：sqlc/pgx for Postgres + Go>"><meta name=twitter:description content="註記：作者本人有攝影的興趣，我拿他的一張相片當封面 XD
Index 導言 前言 Tour database/sql lib/pq pgx go-pg gorm Research Queries as strings ORMs sqlc Codegen pgx support appears Caveats and workarounds Summary and future 導言 這篇文章是專為 Go 開發者寫的，主要翻譯 <How We Went All In on sqlc/pgx for Postgres + Go>，這篇文章的作者本身在 Heroku 工作過也在 stripe 工作過，同時也是提出 Idempotent Key API 的人。
現在他在 Crunchy Data 開發 platform API，對於 Postgres 和 Go 都算是非常有經驗的專家，這篇文章會分享一些他對當前生態環境 Go 如何操作 Postgres 的一些看法。
前言 幾個月的實驗和研究後，我們跑了一些 DB-dependent Go app，我們得到一個結論就是 sqlc 可以說是最好的拿來使用的 Postgres (可以能其他 databases 也是)。而且在 Go code 也很容易使用，以下就讓來介紹一下我們的研究吧！"><script src=https://tachunwu.github.io/js/feather.min.js></script>
<link href=https://tachunwu.github.io/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://tachunwu.github.io/css/main.ac08a4c9714baa859217f92f051deb58df2938ec352b506df655005dcaf98cc0.css></head><body><div class=content><header><script async src="https://www.googletagmanager.com/gtag/js?id=G-2LYZQ778V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2LYZQ778V0")</script><div class=main><a href=https://tachunwu.github.io/>Tachunn Publication</a></div><nav><a href=/>Home</a>
<a href=/posts>All posts</a>
<a href=/about>About</a>
<a href=/tags>Tags</a></nav></header><main><article><div class=title><h1 class=title>&lt;How We Went All In on ：sqlc/pgx for Postgres + Go></h1><div class=meta>Posted on Feb 19, 2023</div></div><section class=body><p><img src=/images/sqlc_head.png alt>
<em>註記：作者本人有攝影的興趣，我拿他的一張相片當封面 XD</em></p><div><h2>Index</h2><nav id=TableOfContents><ol><li><a href=#導言>導言</a></li><li><a href=#前言>前言</a></li><li><a href=#tour>Tour</a><ol><li><a href=#databasesql>database/sql</a></li><li><a href=#libpqhttpsgithubcomlibpq><a href=https://github.com/lib/pq>lib/pq</a></a></li><li><a href=#pgxhttpsgithubcomjackcpgx><a href=https://github.com/jackc/pgx>pgx</a></a></li><li><a href=#go-pghttpsgithubcomgo-pgpg><a href=https://github.com/go-pg/pg>go-pg</a></a></li><li><a href=#gormhttpsgormio><a href=https://gorm.io/>gorm</a></a></li></ol></li><li><a href=#research>Research</a><ol><li><a href=#queries-as-strings>Queries as strings</a></li><li><a href=#orms>ORMs</a></li></ol></li><li><a href=#sqlchttpswwwnotionsohow-we-went-all-in-on-pgx-for-postgres-go-1b1b1b242db14317bf8de9bda27c0fe8><a href=https://www.notion.so/How-We-Went-All-In-on-pgx-for-Postgres-Go-1b1b1b242db14317bf8de9bda27c0fe8>sqlc</a></a><ol><li><a href=#codegen>Codegen</a></li><li><a href=#pgx-support-appears>pgx support appears</a></li><li><a href=#caveats-and-workarounds>Caveats and workarounds</a></li></ol></li><li><a href=#summary-and-future>Summary and future</a></li></ol></nav></div><h1 id=導言>導言</h1><p>這篇文章是專為 Go 開發者寫的，主要翻譯 &lt;<a href=https://brandur.org/sqlc>How We Went All In on sqlc/pgx for Postgres + Go</a>>，<strong>這篇文章的作者本身在 Heroku 工作過也在 stripe 工作過，同時也是提出 Idempotent Key API 的人</strong>。</p><p>現在他在 <a href=https://www.crunchydata.com/>Crunchy Data</a> 開發 platform API，對於 Postgres 和 Go 都算是非常有經驗的專家，這篇文章會分享一些他對當前生態環境 Go 如何操作 Postgres 的一些看法。</p><h1 id=前言>前言</h1><p>幾個月的實驗和研究後，<strong>我們跑了一些 DB-dependent Go app，我們得到一個結論就是 <a href=https://github.com/kyleconroy/sqlc>sqlc</a> 可以說是最好的拿來使用的 Postgres</strong> (可以能其他 databases 也是)。而且在 Go code 也很容易使用，以下就讓來介紹一下我們的研究吧！</p><h1 id=tour>Tour</h1><p>當然我們會研究很多在 Go ecosystem 很有名的 Projects：</p><h2 id=databasesql>database/sql</h2><p>Go built-in 的 database package，我很很多人會同意我，<strong>最好避免使用它。對 database 來說是難以預測的，而且不支援一些 Postgres-specific 的功能。</strong></p><h2 id=libpqhttpsgithubcomlibpq><a href=https://github.com/lib/pq>lib/pq</a></h2><p>一個早期在 Go System 的 Postgres 專案，雖然有它的輝煌時期，<strong>但是現在的維護量已經很少了。</strong></p><h2 id=pgxhttpsgithubcomjackcpgx><a href=https://github.com/jackc/pgx>pgx</a></h2><p><strong>這個 package 寫得非常好</strong>，對 Postgres 提供非常徹底的 full-featured, performant connections。<strong>然而這個專案武斷的不提供 ORM 相關的功能，除了基本的 query interface 根本沒有提供什麼功能。</strong></p><p>就像 <code>database/sql</code> 將 database 和 stuct 集合和是非常痛苦的事情，你不只必需要手動標記 target fields 令人作嘔的字串，還需要手動 <code>Scan</code> 他們進去 struct 內部，。</p><h3 id=scanyhttpsgithubcomgeorgysavvascany><a href=https://github.com/georgysavva/scany>scany</a></h3><p>Scany 在 pgx 上面加了一些讓你使用 pgx 生活更快樂的功能，但是你還是需要羅列 field names 在 <code>SELECT …</code> 之中，<strong>所以只算提供了半個樣板。</strong></p><h2 id=go-pghttpsgithubcomgo-pgpg><a href=https://github.com/go-pg/pg>go-pg</a></h2><p><strong>我個人以前有用過這個 Project，這其實是個蠻好用的 Postgres-specific ORM</strong>。下面我們會花篇幅說明 ORMs 對 Go 的缺點，<strong>還有 go-pg 的另一個缺點就是它時做了自己的 driver，不能相容 pgx。</strong></p><h3 id=bunhttpsbunuptracedevguidepg-migrationhtmlnew-features><a href=https://bun.uptrace.dev/guide/pg-migration.html#new-features>Bun</a></h3><p>go-pg 還有被收錄進去 Bun 來 maintain，重寫了 go-pg rewrite 但是去使用 non-Postgres databases，自然不在本篇的討論範圍內。</p><h2 id=gormhttpsgormio><a href=https://gorm.io/>gorm</a></h2><p>一樣和 go-pg 差不多特性，但是不只是針對 Postgres，還包還了其他的 database。你可以使用 pgx 當 driver，但是失去了很多 Postgres features。</p><h1 id=research>Research</h1><h2 id=queries-as-strings>Queries as strings</h2><p>對於原生 <code>database/sql</code> 和 <code>pgx</code> 最大的缺點就是 SQL queries 是 strings：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>name</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>weight</span> <span style=color:#66d9ef>int64</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>QueryRow</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>&#34;SELECT name, weight FROM widgets WHERE id = $1&#34;</span>, <span style=color:#ae81ff>42</span>).
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Scan</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>name</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>weight</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>weight</span>)
</span></span></code></pre></div><p>當然這些 queries 很簡單，<strong>但是實際的查詢其實沒有什麼信心它們可以 work。compiler 只會看到一個 string 然後你還需要些額外得測試去驗證他們。</strong></p><p>更糟剛的事情是當你在寫一個大型的 Application，需要去混合一些 models 來減少 code 的重複率。你可能開始將這些 string 黏在一起，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>conn</span>.<span style=color:#a6e22e>QueryRow</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#e6db74>`SELECT `</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>scanTeamFields</span> <span style=color:#f92672>+</span> <span style=color:#960050;background-color:#1e0010>`</span> <span style=color:#f92672>...</span>)
</span></span></code></pre></div><h2 id=orms>ORMs</h2><p>ORMs 像是 go-pg 混合了一些 type，某種程度上避免了錯誤，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>story</span> <span style=color:#f92672>:=</span> new(<span style=color:#a6e22e>Story</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Model</span>(<span style=color:#a6e22e>story</span>).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Relation</span>(<span style=color:#e6db74>&#34;Author&#34;</span>).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Where</span>(<span style=color:#e6db74>&#34;story.id = ?&#34;</span>, <span style=color:#a6e22e>story1</span>.<span style=color:#a6e22e>Id</span>).
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Select</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然而沒有 generics (現在版本已經有了 XD)，Go 的 type system 能提供的也只有這樣，務實上 compiler 無法檢查到我們連接更多字串的情境。</p><p>在上面的 code，<code>Model()</code>回傳了一個 <code>*Query</code> 物件。<code>Relation()</code> 一樣也回傳 <code>*Query</code> 物件、<code>Where()</code> 也一樣。pg-go 的確有做一些優化，<strong>但是這些錯誤只能能在 runtime 被發現。</strong></p><p><strong>ORMs 還有一個問題，與大多數習慣 SQL 得人還需要時間去適應 ORM，意味著你可能花整天的時間在看文件，只是為了翻譯 SQL ORM 之中。簡單的 queries 雖然不用花太多時間，但是試著想想看如果要處理 upsert 或是 CTE 之類的功能。</strong></p><h1 id=sqlchttpswwwnotionsohow-we-went-all-in-on-pgx-for-postgres-go-1b1b1b242db14317bf8de9bda27c0fe8><a href=https://www.notion.so/How-We-Went-All-In-on-pgx-for-Postgres-Go-1b1b1b242db14317bf8de9bda27c0fe8>sqlc</a></h1><p>在以上的研究後，我們發現了 sqlc。你可以簡單的寫 <code>*.sql</code> files，其中可以包涵 table 和 query，只需要加簡單的註解，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> authors (
</span></span><span style=display:flex><span>  id   BIGSERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  name text      <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  bio  text
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- name: CreateAuthor :one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> authors (
</span></span><span style=display:flex><span>  name, bio
</span></span><span style=display:flex><span>) <span style=color:#66d9ef>VALUES</span> (
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>1</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>RETURNING <span style=color:#f92672>*</span>; 
</span></span></code></pre></div><p>之後你可以用 <code>sqlc generate</code> 自動產生 Go code，你會得到像是下面的結果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>author</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>dbsqlc</span>.<span style=color:#a6e22e>New</span>(<span style=color:#a6e22e>tx</span>).<span style=color:#a6e22e>CreateAuthor</span>(<span style=color:#a6e22e>ctx</span>, <span style=color:#a6e22e>dbsqlc</span>.<span style=color:#a6e22e>CreateAuthor</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Name</span>: <span style=color:#e6db74>&#34;Haruki Murakami&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Bio</span>:  <span style=color:#e6db74>&#34;Author of _Killing Commendatore_. Running and jazz enthusiast.&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>xerrors</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;error creating author: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Author name: %s\n&#34;</span>, <span style=color:#a6e22e>author</span>.<span style=color:#a6e22e>Name</span>)
</span></span></code></pre></div><p><strong>sqlc 不算是 ORM 但它實作了一樣最有用的功能，就是 mapping query 回到 struct 而不用任何的 boilerplate</strong>。</p><p>如果你由一個 query 包含了 <code>SELECT *</code> 或是 <code>RETURNING *</code>，<strong>它會知道要回傳什麼東西並且綁定回去 strcut，所也的特定 table 的 queries 都有相同的 output 結構。</strong></p><p><strong>sqlc 本身用 <a href=https://github.com/pganalyze/pg_query_go>PGAnalyze</a>，這和 Postgres 的 query parser 基本上是同一個</strong>。到目前為止都沒有給我帶過什麼麻煩，而且非常複雜的查詢也能順利執行。</p><p><strong>這個 query parsing 還有 pre-runtime code verification，可以預先確認你的 code 是不是有 bug，如果你的 SQL 寫錯，編譯到 Go 就直接不會過。比起 SQL-in-Go-strings 實在是好太多了。如果你還是想要寫測試也是可以，不過你不需要去考慮所有詳盡的 corner case。</strong></p><h2 id=codegen>Codegen</h2><p>其實我個人得哲學對 codegen 有點 ”過敏”，讓我不太願意花時間深入研究。</p><p>不過最終 sqlc 獲得了我的青睞。sqlc 就像其他 pkg 安裝一樣簡單只需要一個指令就可以了 (<code>go install github.com/kyleconroy/sqlc/cmd sqlc@latest</code>)，<strong>而且我們的而且我們的 project 包含超過 100 個 queries，實際上編譯完成的時間不到一秒鐘！</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ time sqlc generate
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>real    0.07s
</span></span><span style=display:flex><span>user    0.08s
</span></span><span style=display:flex><span>sys     0.01s
</span></span></code></pre></div><p>我想就算我我們把 queries 的數量增加 x100 變成 10000，我在開發生時也不會造成太大的障礙。</p><h2 id=pgx-support-appears>pgx support appears</h2><p>在這之前，<strong>我們最大原因沒有選擇 sqlc 的原因是因為不支援 pgx</strong>，不過最近的 PR 已經解決了這個問題，而且還提供很多的 driver 供我們使用。</p><p><strong>sqlc 的作者們用非常 loosely coupled 的方式去寫。像我們很多專案已經大量依賴 pgx，但是我依然能夠在一個小時內把 sqlc 的 code 遷移到 pgx 上面，這讓我們 migrate code 變得非常輕鬆！</strong></p><h2 id=caveats-and-workarounds>Caveats and workarounds</h2><p>比起傳統 ORM sqlc 還是有一些比較不方便的地方，但是有方法可以很好的解決。例如：sqlc 不能任意填寫參數，所以 multi-row insert 可能不會像你預期的一樣執行，但是你可以採取傳輸 batch 當作 array 的方式去執行它，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Upsert many marketplaces, inserting or replacing data as necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>INSERT</span> <span style=color:#66d9ef>INTO</span> marketplace (
</span></span><span style=display:flex><span>    name,
</span></span><span style=display:flex><span>    display_name
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> <span style=color:#66d9ef>unnest</span>(<span style=color:#f92672>@</span><span style=color:#66d9ef>names</span>::text[]) <span style=color:#66d9ef>AS</span> name,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unnest</span>(<span style=color:#f92672>@</span>display_names::text[]) <span style=color:#66d9ef>AS</span> display_names
</span></span><span style=display:flex><span><span style=color:#66d9ef>ON</span> CONFLICT (name)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>DO</span> <span style=color:#66d9ef>UPDATE</span> <span style=color:#66d9ef>SET</span> display_name <span style=color:#f92672>=</span> EXCLUDED.display_name
</span></span><span style=display:flex><span>RETURNING <span style=color:#f92672>*</span>;
</span></span></code></pre></div><p>另外一個例子則是 <code>UPDATE</code>，正常來說 ORM 就是把目標欄位的的數值填上去就好 (例如：<code>UPDATE foo SET a = 1, b = 2, c = 3, …</code>)。這種方式在 sqlc 是行不通的，所有的 Queries 都必須事先結構化，所以你可以在更新時帶入 bool 的方式確認，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#75715e>-- Update a team.
</span></span></span><span style=display:flex><span><span style=color:#75715e>-- name: TeamUpdate :one
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>UPDATE</span> team
</span></span><span style=display:flex><span><span style=color:#66d9ef>SET</span>
</span></span><span style=display:flex><span>    customer_id <span style=color:#f92672>=</span> <span style=color:#66d9ef>CASE</span> <span style=color:#66d9ef>WHEN</span> <span style=color:#f92672>@</span>customer_id_do_update::boolean
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>THEN</span> <span style=color:#f92672>@</span>customer_id::VARCHAR(<span style=color:#ae81ff>200</span>) <span style=color:#66d9ef>ELSE</span> customer_id <span style=color:#66d9ef>END</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    has_payment_method <span style=color:#f92672>=</span> <span style=color:#66d9ef>CASE</span> <span style=color:#66d9ef>WHEN</span> <span style=color:#f92672>@</span>has_payment_method_do_update::boolean
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>THEN</span> <span style=color:#f92672>@</span>has_payment_method::bool <span style=color:#66d9ef>ELSE</span> has_payment_method <span style=color:#66d9ef>END</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> <span style=color:#66d9ef>CASE</span> <span style=color:#66d9ef>WHEN</span> <span style=color:#f92672>@</span>name_do_update::boolean
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>THEN</span> <span style=color:#f92672>@</span>name::text <span style=color:#66d9ef>ELSE</span> name <span style=color:#66d9ef>END</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span>
</span></span><span style=display:flex><span>    id <span style=color:#f92672>=</span> <span style=color:#f92672>@</span>id
</span></span><span style=display:flex><span>RETURNING <span style=color:#f92672>*</span>;
</span></span></code></pre></div><p>Go 生成的 code 就會像是這樣</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>team, err <span style=color:#f92672>=</span> queries.TeamUpdate(ctx, dbsqlc.TeamUpdateParams<span style=color:#960050;background-color:#1e0010>{</span>
</span></span><span style=display:flex><span>    NameDoUpdate: <span style=color:#66d9ef>true</span>,
</span></span><span style=display:flex><span>    Name:         req.Name,
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>}</span>)
</span></span></code></pre></div><h1 id=summary-and-future>Summary and future</h1><p>以上我已經介紹了大部分的 sqlc 的好處，感覺就像是用 Go 一樣我可以快速又正確的完成我的工作，不用整天和計算機本身對著幹。</p><p>不過我不會說它是整個 ecosystems 最好的解決方案，Rust’s SQL drivers 也有可能做出像魔法一樣的東西，不過至少在 Go 領域沒有疑問 sqlc 是最好的方案。</p><p>未來 Go 會引入 generics，可能會徹底改變這個專案內部建構的模式，或是啟發新的 ORMs，但至少這一兩年的經驗我們對 sqlc 非常滿意！</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/engineering>Engineering</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/tachunwu rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a></div><div class=footer-info>2023 💠 © Tachunn | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-2LYZQ778V0"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2LYZQ778V0")</script><script>feather.replace()</script></div></body></html>